- Watching [[Fundamentals of Distributed Systems]]
	- There might be both business and technical reasons to build separate services. Business decisions involve different incentives, decision makers. Technical reasons are independent data stores, different release schedule (release velocity) and usage patters (need for scaling)
	- Service design workshop including [[Event Storming]] (idea of [[Alberto Brandolini]]) can be used to design service boundary.
	- Conway's Law (idea of [[Melvin E. Conway]]) explains how software architecture relates to the way we structure communication in our teams. [[Reverse Conway Manoeuvre]] describes a change in organisational structure to arrive at desired software architecture.
	- [[Domain-Driven Design]] (idea of [[Eric Evans]]) is another useful technique for designing services
	- [[The Art of Immutable Architecture]] and the [[Historical Modelling]] are following from the [[Domain-Driven Design]] and add immutability to help design systems.
	- Putting it all together
		- [[Event Storming]] - identifies and captures all events, commands and aggregates in the system showing how they flow through the system
		- [[Domain Model]] - maps aggregates within [[Bounded Context]]s so nobody can confuse two aggregates that happen to have the same name
		- [[Historical Model]] - maps the relationships between historical facts. It identifies predecessors so we know which fact went to make which decision and identify the actors who made those decisions.
	- [[Temporal Coupling]] - clients blocked while waiting on servers.
		- This can be mitigated by multithreading, promises and so on, but it is still a coupling and failure on the server will result, most likely, on client failure. The alternative is to separate the delivery of messages and the processing of data using messaging.
	- [[Synchronous Protocol]] - response conveys information about processing. Examples: [[HTTP]], [[SOAP]], [[gRPC]], [[REST]].
	- [[Asynchronous Protocol]] - response conveys only information about delivery. Examples: [[AMGP]], [[Apache Kafka]], [[IBM MQ]], [[Amazon SQS]]. An unfortunate coincidence here is that most of asynchronous protocols are based on implementation not standards and so we tend to have preference for synchronous ones.
	- Queries can be synchronous as it makes the design easier and anyway we need to have the content of body. But commands should by asynchronous and should not return values anyway.
	- When designing external interactions between organisations (using [[API]]s) we may draw inspiration from business processes developed and perfected over centuries. Those are typically asynchronous. [[Remote Procedure Call]] ([[RPC]]) interfaces should be avoided as they introduce [[Temporal Coupling]]. Messaging protocols are tied to specific implementations and are not good as standards. The best option is to use [[HTTP]] in an asynchronous manner.
	- [[REST]]-like architecture is beneficial but [[REST]] is focused on mutable resources, so it has to be modified to work with immutable data.
		- Queries will use synchronous GET requests
		- Some commands, if they need immediate response will be POST and return data with 201 response
		- Some commands will be asynchronous and will be POST returning 202 accepted response.
		-
		-
		-
		-
		-
		-