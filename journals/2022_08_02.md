- Watching [[Fundamentals of Distributed Systems]]
	- There might be both business and technical reasons to build separate services. Business decisions involve different incentives, decision makers. Technical reasons are independent data stores, different release schedule (release velocity) and usage patters (need for scaling)
	- Service design workshop including [[Event Storming]] (idea of [[Alberto Brandolini]]) can be used to design service boundary.
	- Conway's Law (idea of [[Melvin E. Conway]]) explains how software architecture relates to the way we structure communication in our teams. [[Reverse Conway Manoeuvre]] describes a change in organisational structure to arrive at desired software architecture.
	- [[Domain-Driven Design]] (idea of [[Eric Evans]]) is another useful technique for designing services
	- [[The Art of Immutable Architecture]] and the [[Historical Modelling]] are following from the [[Domain-Driven Design]] and add immutability to help design systems.
	- Putting it all together
		- [[Event Storming]] - identifies and captures all events, commands and aggregates in the system showing how they flow through the system
		- [[Domain Model]] - maps aggregates within [[Bounded Context]]s so nobody can confuse two aggregates that happen to have the same name
		- [[Historical Model]] - maps the relationships between historical facts. It identifies predecessors so we know which fact went to make which decision and identify the actors who made those decisions.
	- [[Temporal Coupling]] - clients blocked while waiting on servers.
		- This can be mitigated by multithreading, promises and so on, but it is still a coupling and failure on the server will result, most likely, on client failure. The alternative is to separate the delivery of messages and the processing of data using messaging.
	- [[Synchronous Protocol]] - response conveys information about processing. Examples: [[HTTP]], [[SOAP]], [[gRPC]], [[REST]].
	- [[Asynchronous Protocol]] - response conveys only information about delivery. Examples: [[AMGP]], [[Apache Kafka]], [[IBM MQ]], [[Amazon SQS]]. An unfortunate coincidence here is that most of asynchronous protocols are based on implementation not standards and so we tend to have preference for synchronous ones.
	- Queries can be synchronous as it makes the design easier and anyway we need to have the content of body. But commands should by asynchronous and should not return values anyway.
	- When designing external interactions between organisations (using [[API]]s) we may draw inspiration from business processes developed and perfected over centuries. Those are typically asynchronous. [[Remote Procedure Call]] ([[RPC]]) interfaces should be avoided as they introduce [[Temporal Coupling]]. Messaging protocols are tied to specific implementations and are not good as standards. The best option is to use [[HTTP]] in an asynchronous manner.
	- [[REST]]-like architecture is beneficial but [[REST]] is focused on mutable resources, so it has to be modified to work with immutable data.
		- Queries will use synchronous GET requests
		- Some commands, if they need immediate response will be POST and return data with 201 response
		- Some commands will be asynchronous and will be POST returning 202 accepted response.
- Watching [[The Value of Flow]]
	- Definitions of efficient:
		- From OED: achieving maximum productivity with minimum wasted effort or expense
		- From Merriam-Webster: capable of producing desired results without wasting materials time or energy.
	- Steps to increase value of 'flow' follow the cycle of change.
		- Visualise - turn the lights on and see what's there. Visualisation can already make things better.
		- Stabilise - doesn't matter if it is good or bad, to improve first we need to be predictable otherwise we won't know if what we are changing makes things better or worse. But similarly to visualisation just stabilisation can improve things
		- Optimise - that is the last step. It's natural as in tech we are tinkerers. That's the most fun.
	- Dan North says that from his experience of mapping processes in many organisations he has never seen a process that was less than 90% of wait time compared to the total time (value + wait). We don't see that, because we look at resource efficiency not system efficiency. Resource Efficiency is about keeping people busy. This is the idea of sweating the assets. But this high percentage of 'efficiency' or rather business is not very productive as there is a lot of context switching going on.
		- This is something I have seen in in [[The Phoenix Project]], [[Peopleware: Productive Projects and Teams]], [[Deep Work]] and probably a few more books. The Peopleware book talks about flow in brain time vs body time and also quotes 90% productivity data. More specifically 0.38 to 0.10 E-Factor which is (uninterrupted hours)/(body-present hours).
		- These are examples of local optimisation which destabilise flow.
	- [[John Little]]'s diagram of cycle time depending on utilisation is another diagram I have seen before, but it is a very powerful idea. The function is an asymptote and so at 100% utilisation the cycle time is infinite.
		- Optimising for resource efficiency destroys throughput.
		- _my observations_: But the challenge is that the "work expands so as to fill the time available for its completion." [[Parkinson's Law]].
	- [[The Goal: A process of Ongoing Improvement]] explains well the [[Theory of Constraints]] - each system has its natural capacity. There is no the graphical novel too.
	- To become more efficient we need to first reset the system.
	-
	-
	-
	-
	-